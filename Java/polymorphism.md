## 다형성이란?

* 다형성(Polymorphism)은 **한 객체가 하나의 인터페이스나 추상 클래스를 통해 여러 타입의 객체로 취급될 수 있는 특성**을 뜻한다.
* 보통 하나의 객체는 하나의 타입으로 고정되어 있다. 그런데 다형성을 사용하면 하나의 객체가 다른 타입으로 사용될 수 있다는 뜻이다. 
* 다형성을 이해하기 위해서는 크게 ``다형적 참조``, ``메서드 오버라이딩``이라는 2가지 핵심 이론을 알아야 한다.

<br>

## 다형적 참조

* 다형적 참조의 핵심은 **부모는 자식을 품을 수 있다는 것**이다.
* 자바에서 부모 타입은 자신은 물론이고, 자신을 기준으로 모든 자식 타입을 참조할 수 있다.
* 이것이 바로 다양한 형태를 참조할 수 있다고 해서 ``다형적 참조``라 한다.

<br>

### 다형적 참조와 인스턴스 실행

* 인스턴스에서 메서드를 호출할 때, 변수에 선언된 클래스부터 시작해서 없다면 부모 클래스로 올라가며 해당 메서드를 찾는다.
* 만약, 부모 클래스로 선언된 변수에서 자식을 참조한 인스턴스가 있고, 자식 클래스에 존재하는 메서드를 호출하면 해당 메서드를 찾을 수 없어 컴파일 오류가 발생한다.
* 이를 해결하려면, 메서드를 호출하는 인스턴스의 타입을 자식 클래스로 ``다운캐스팅``하는 것이다.
* 부모 타입으로 변환하는 경우에는 다음과 같이 캐스팅 코드인 (타입) 를 생략할 수 있다.
  * ``업캐스팅(upcasting)``: 부모 타입으로 변경
  * ``다운캐스팅(downcasting)``: 자식 타입으로 변경
* **업캐스팅은 생략할 수 있으나, 다운캐스팅은 생략할 수 없다.** 참고로 업캐스팅은 매우 자주 사용하기 때문에 생략을 권장한다.

<br>

## 다형성과 메서드 오버라이딩

* 메서드 오버라이딩에서는 **오버라이딩 된 메서드가 항상 우선권을 가진다**.
* 따라서, 부모 클래스로 선언된 변수에서 자식을 참조한 인스턴스가 있고, 부모 클래스에서 자식 클래스에서 오버라이딩된 메서드를 호출하면 부모 메서드가 아닌, 자식 메서드가 호출된다.

<br>

## 다형성이 필요한 이유

```
예를 들어, 개, 고양이, 소의 울음 소리를 테스트하는 프로그램을 작성해본다고 생각해보자.
Dog, Cat, Caw 클래스는 울음 소리를 출력하는 sound() 메서드를 공통적으로 가지고 있다.
만약, 여기서 새로운 동물이 추가될수록 sound() 메서드는 중복이 증가한다.
중복을 제거하기 위해서는 메서드를 사용하거나, 또는 배열과 for 문을 사용하면 되지만, Dog, Cat, Caw 클래스는 서로 완전히 다른 클래스이다.
타입이 서로 다르기 때문에 중복 제거가 불가능하다.
즉, Dog, Cat, Caw 클래스 가 모두 같은 타입을 사용할 수 있는 방법이 있다면, 메서드와 배열을 활용해서 코드의 중복을 제거할 수 있다는 것이다.
다형성의 핵심은 다형적 참조와 메서드 오버라이딩이다. 이 둘을 활용하면 Dog , Cat , Caw 가 모두 같은 타입을 사용하고, 각자 자신의 메서드도 호출할 수 있다.
다형성을 사용하기 위해, 상속 관계를 이용해 Animal 이라는 부모 클래스를 만들고 sound() 메서드를 정의한다.
이 메서드는 자식 클래스에서 오버라이딩 할 목적으로 만들었다.
Dog, Cat, Caw 클래스 는 Animal 클래스를 상속받았다. 그리고 각각 부모의 sound() 메서드를 오버라이딩 한다.
다형적 참조 덕분에 Animal 클래스로 선언된 animal 변수는 자식인 Dog, Cat, Caw 클래스 의 인스턴스를 참조할 수 있고,
메서드 오버라이딩 덕분에 animal.sound() 를 호출해도 Dog.sound() , Cat.sound() , Caw.sound() 와 같이 각 인스턴스의 메서드를 호출할 수 있다.
```

즉, 다형성을 이용하면 배열에 다른 타입의 인스턴스를 담아 관리할 수 있고, 공통된 메서드의 중복을 제거하면서 동시에 호출하기에도 용이하다.

<br>

## 추상 클래스란?

* 추상 클래스는 이름 그대로 추상적인 개념을 제공하는 클래스이다. 즉, 부모 클래스는 제공하지만, 실제 생성되면 안되는 클래스이다.
* 추상 클래스는 실체인 인스턴스가 존재하지 않지만, 대신에 **상속**을 목적으로 사용되고, 부모 클래스 역할을 담당한다.
* 추상 클래스는 클래스를 선언할 때 앞에 추상이라는 의미의 ``abstract`` 키워드를 붙여주면 된다.
* 추상 클래스는 기존 클래스와 완전히 같지만, **직접 인스턴스를 생성하지 못하는 제약이 추가**된 것이다.

<br>

## 추상 메서드

* 부모 클래스를 상속 받는 **자식 클래스가 반드시 오버라이딩 해야 하는 메서드**를 부모 클래스에 정의할 수 있다. 이것을 추상 메서드라 한다.
* 추상 메서드는 이름 그대로 추상적인 개념을 제공하는 메서드이다. 따라서 실체가 존재하지 않고, 메서드 바디가 없다.
* 추상 메서드는 선언할 때 메서드 앞에 추상이라는 의미의 ``abstract`` 키워드를 붙여주면 된다.
* **추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 한다.**
  * 추상 메서드는 메서드 바디가 없다. 따라서 작동하지 않는 메서드를 가진 불완전한 클래스로 볼 수 있다.
  * 따라서, 직접 생성하지 못하도록 추상 클래스로 선언해야 한다. 그렇지 않으면 컴파일 오류가 발생한다.
* **추상 메서드는 상속 받는 자식 클래스가 반드시 오버라이딩 해서 사용해야 한다.**
  * 그렇지 않으면 컴파일 오류가 발생한다.
  * 추상 메서드는 자식 클래스가 반드시 오버라이딩 해야 하기 때문에 메서드 바디 부분이 없다. 바디 부분을 만들면 컴파일 오류가 발생한다.
  * 오버라이딩 하지 않으면 자식도 추상 클래스가 되어야 한다.
* 추상 메서드는 기존 메서드와 완전히 같다. 다만 메서드 바디가 없고, 자식 클래스가 해당 메서드를 반드시 오버라이딩 해야 한다는 제약이 추가된 것이다.

<br>

## 순수 추상 클래스

* 모든 메서드가 추상 메서드인 추상 클래스를 ``순수 추상 클래스``라고 하는데, 코드를 실행할 바디 부분이 전혀 없다. 즉, 실행 로직을 전혀 가지고 있지 않다.
* 순수 추상 클래스는 단지 다형성을 위한 부모 타입으로써 껍데기 역할만 제공할 뿐이다.
* 순수 추상 클래스는 다음과 같은 특징을 가진다.
  * 인스턴스를 생성할 수 없다.
  * 상속시 자식은 모든 메서드를 오버라이딩 해야 한다.
  * 주로 다형성을 위해 사용된다.

<br>

## 인터페이스

* 자바는 순수 추상 클래스를 더 편리하게 사용할 수 있도록 ``인터페이스``라는 개념을 제공한다.
* 인터페이스는 class 가 아니라 ``interface`` 키워드를 사용하면 된다.
* 인터페이스는 앞서 설명한 순수 추상 클래스와 같다. 여기에 약간의 편의 기능이 추가된다.
  * 인터페이스의 메서드는 모두 ``public`` , ``abstract`` 이다.
  * 메서드에 ``public``, ``abstract`` 를 생략할 수 있다. 참고로 생략이 권장된다.
  * 인터페이스는 **다중 구현(다중 상속)** 을 지원한다.
* 인터페이스에서 멤버 변수는 ``public`` , ``static`` , ``final`` 이 모두 포함되었다고 간주된다. 즉, 멤버 변수는 **상수**취급 된다.
* 인터페이스를 상속 받을 때는 ``extends`` 대신에 ``implements`` 라는 구현이라는 키워드를 사용해야 한다. 인터페이스는 그래서 상속이라 하지 않고 구현이라 한다.
* 클래스, 추상 클래스, 인터페이스는 프로그램 코드, 메모리 구조상 모두 똑같다. 모두 자바에서는 .class 로 다루어진다. 인터페이스를 작성할 때도 .java 에 인터페이스를 정의한다.

<br>

> 인터페이스를 사용해야 하는 이유?

모든 메서드가 추상 메서드인 경우 순수 추상 클래스를 만들어도 되고, 인터페이스를 만들어도 된다. 그런대 왜 인터페이스를 사용해야 할까?
* 제약 : 인터페이스를 만드는 이유는 인터페이스를 구현하는 곳에서 인터페이스의 메서드를 반드시 구현해라는 규약(제약)을 주는 것이다.
USB 인터페이스를 생각해보자. USB 인터페이스에 맞추어 키보드, 마우스를 개발하고 연결해야 한다.
그렇지 않으면 작동하지 않는다. 인터페이스의 규약(제약)은 반드시 구현해야 하는 것이다.
그런데, 순수 추상 클래스의 경우 미래에 누군가 그곳에 실행 가능한 메서드를 끼워 넣을 수 있다.
이렇게 되면 추가된 기능을 자식 클래스에서 구현하지 않을 수도 있고, 또 더는 순수 추상 클래스가 아니게 된다.
반면, 인터페이스는 모든 메서드가 추상 메서드이다. 따라서 이런 문제를 원천 차단할 수 있다.

* 다중 구현 : 자바에서 클래스 상속은 부모를 하나만 지정할 수 있다. 반면에 인터페이스는 부모를 여러명 두는 다중 구현(다중 상속)이 가능하다.

<br>

> 자바에서 다중 상속을 지원하지 않는 이유?

자바는 다중 상속을 지원하지 않는다. 그래서 extends 대상은 하나만 선택할 수 있다. 부모를 하나만 선택할 수 있다는 뜻이다.
물론 부모가 또 부모를 가지는 것은 괜찮다. 
예를 들어, 비행기와 자동차를 상속 받아서 하늘을 나는 자동차를 만든다고 가정해보자. 
만약 다중 상속을 사용하게 되면, 두 클래스를 상속받은 ``AirplaneCar`` 입장에서 ``move()`` 를 호출할 때, 어떤 부모의 ``move()``를 사용해야 할지 애매한 문제가 발생한다. 
이것을 다이아몬드 문제라 한다. 그리고 다중 상속을 사용하면 클래스 계층 구조가 매우 복잡해지 수 있다.
이런 문제점 때문에 자바는 클래스의 다중 상속을 허용하지 않는다. 대신에 **인터페이스의 다중 구현을 허용**하여 이러한 문제를 피한다.

<br>

> 클래스는 앞서 설명한 이유로 다중 상속이 안되는데, 인터페이스의 다중 구현은 허용한 이유는 뭘까?

**인터페이스는 모두 추상 메서드로 이루어져 있기 때문이다.**
예를 들어, ``InterfaceA`` , ``InterfaceB`` 는 둘다 같은 ``methodCommon()`` 을 가지고 있다고 생각해보자. 그리고 ``Child`` 는 두 인터페이스를 구현했다.
상속 관계의 경우 두 부모 중에 어떤 한 부모의 methodCommon() 을 사용해야 할지 결정해야 하는 다이아몬드 문제가 발생한다.
하지만 인터페이스 자신은 구현을 가지지 않는다. 대신에 인터페이스를 구현하는 곳에서 해당 기능을 모두 구현해야 한다. 
여기서 ``InterfaceA`` , ``InterfaceB`` 는 같은 이름의 ``methodCommon()`` 를 제공하지만 이것의 기능은 ``Child``가 구현한다. 
그리고 오버라이딩에 의해 어차피 Child 에 있는 methodCommon() 이 호출된다. 
결과적으로, 두 부모 중에 어떤 한 부모의 methodCommon() 을 선택하는 것이 아니라, 그냥 인터페이스들을 구현한 Child 에 있는 methodCommon() 이 사용된다. 
이런 이유로 인터페이스는 다이아몬드 문제가 발생하지 않는다. 따라서 인터페이스의 경우 다중 구현을 허용한다.
